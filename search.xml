<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>给定二叉树前序、中序、后续遍历其中两种，构造二叉树</title>
      <link href="/suan-fa/gei-ding-er-cha-shu-qian-xu-zhong-xu-hou-xu-bian-li-qi-zhong-liang-chong-gou-zao-er-cha-shu/"/>
      <url>/suan-fa/gei-ding-er-cha-shu-qian-xu-zhong-xu-hou-xu-bian-li-qi-zhong-liang-chong-gou-zao-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<p>给定二叉树的前序、中序、后续遍历其中两种，如何构造<a href="/suan-fa/bian-li-er-cha-shu/" title="二叉树">二叉树</a>？</p><h2 id="1-给定前序、中序遍历"><a href="#1-给定前序、中序遍历" class="headerlink" title="1. 给定前序、中序遍历"></a>1. 给定前序、中序遍历</h2><blockquote><p>In-order: F, B, A, E, H, C, D, I, G</p><p>Pre-order: H, B, F, E, A, C, D, G, I</p></blockquote><p>由于前序遍历最先访问根节点。可以确定H为根节点。而中序遍历的顺序为：左子树、根、右子树。所以可以确定中序遍历中，H前面的所有元素构成左子树。后面的所有元素构成右子树。由此可以做如下划分：</p><blockquote><p>In-order: <font color="blue">F, B, A, E, </font><font color="red">H, </font><font color="green">C, D, I, G</font></p><p>Pre-order: <font color="red">H, </font><font color="blue">B, F, E, A, </font><font color="green">C, D, G, I</font></p></blockquote><p>其中<font color="red">红色</font>为根节点、<font color="blue">蓝色</font>为左子树、<font color="green">绿色</font>为右子树。</p><p>然后递归的对左子树和右子树做同样的操作。最终构建的二叉树为：</p><p><img src="../../images/Screen Shot 2018-12-11 at 10.52.56 AM.jpg" alt="Screen Shot 2018-12-11 at 10.52.56 AM"></p><hr><p>同理，给定其他遍历顺序时，颜色划分如下。</p><h2 id="2-给定后序、中序遍历"><a href="#2-给定后序、中序遍历" class="headerlink" title="2. 给定后序、中序遍历"></a>2. 给定后序、中序遍历</h2><blockquote><p>In-order: <font color="blue">F, B, A, E, </font><font color="red">H, </font><font color="green">C, D, I, G</font></p><p>Post-order: <font color="blue">F, A, E, B, </font><font color="green">I, G, D, C, </font><font color="red">H</font></p></blockquote><h2 id="3-给定前序、后序遍历"><a href="#3-给定前序、后序遍历" class="headerlink" title="3. 给定前序、后序遍历"></a>3. 给定前序、后序遍历</h2><blockquote><p>Pre-order: <font color="red">H, </font>B, F, E, A, C, D, G, I</p><p>Post-order: F, A, E, B, I, G, D, C, <font color="red">H</font></p></blockquote><p>这种情况下，我们首先能判断根节点是<font color="red">H</font>，接下来是如何判断左右子树。</p><p>由于后序遍历最后访问根节点。所以根节点之前的所有元素，构成了以该点为根的子树。通过先序遍历，我们知道B是左子树的根节点。在后序遍历中找到B，那么B前面的所有节点即为左子树。因此我们就找到了左右子树。如下：</p><blockquote><p>Pre-order: <font color="red">H, </font><font color="blue">B, F, E, A, </font><font color="green">C, D, G, I</font></p><p>Post-order: <font color="blue">F, A, E, B, </font><font color="green">I, G, D, C, </font><font color="red">H</font></p></blockquote><p>对左右子树进行同样的操作，即可得到整个树。</p><hr><p><strong>后记：</strong></p><p>遇到给定二叉树的两种遍历序列后，求第三种遍历序列都可以用上述的方法，先构建出树。再给出另外一种遍历序列。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>遍历二叉树</title>
      <link href="/suan-fa/bian-li-er-cha-shu/"/>
      <url>/suan-fa/bian-li-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<p>二叉树的知识点及遍历方法整理。</p><h2 id="1-什么是二叉树？"><a href="#1-什么是二叉树？" class="headerlink" title="1. 什么是二叉树？"></a>1. 什么是二叉树？</h2><blockquote><p>二叉树是每个结点最多有两个分支的树结构。通常被称作“左子树”和“右子树”。二叉树的分支具有左右次序，不能随意颠倒。</p></blockquote><h2 id="2-二叉树种类"><a href="#2-二叉树种类" class="headerlink" title="2. 二叉树种类"></a>2. 二叉树种类</h2><h3 id="2-1-斜树"><a href="#2-1-斜树" class="headerlink" title="2.1 斜树"></a>2.1 斜树</h3><blockquote><p>所有节点只有左子树，或者右子树。</p></blockquote><h3 id="2-2-满二叉树"><a href="#2-2-满二叉树" class="headerlink" title="2.2 满二叉树"></a>2.2 满二叉树</h3><blockquote><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。</p></blockquote><h3 id="2-3-完全二叉树"><a href="#2-3-完全二叉树" class="headerlink" title="2.3 完全二叉树"></a>2.3 完全二叉树</h3><blockquote><p>除了最后一层允许填不满外，其他层均填满。而且最后一层靠左填充。</p></blockquote><p><img src="../../images/CompleteBinary.jpg" alt="CompleteBinary"></p><h3 id="2-4-二叉搜索树"><a href="#2-4-二叉搜索树" class="headerlink" title="2.4 二叉搜索树"></a>2.4 二叉搜索树</h3><blockquote><p>左子树上所有节点值 &lt; 根节点 &lt; 右子树上所有节点值。</p><p>二叉搜索树在中序遍历下单调递增。</p></blockquote><h3 id="2-5-平衡二叉树"><a href="#2-5-平衡二叉树" class="headerlink" title="2.5 平衡二叉树"></a>2.5 平衡二叉树</h3><blockquote><p>左右两个子树的高度差绝对值不超过1。并且左右子树均为平衡二叉树。</p><p>常用算法有：</p><ul><li>红黑树</li><li>AVL</li><li>Treap</li><li>伸展树</li></ul></blockquote><h2 id="3-二叉树性质"><a href="#3-二叉树性质" class="headerlink" title="3. 二叉树性质"></a>3. 二叉树性质</h2><ol><li>二叉树第i层，节点数目最多为$2^{i-1}$</li><li>任意一颗二叉树，若叶节点为n，度为2的接单树为m，则n = m + 1</li><li>深度为h的满二叉树，节点数为$2^h-1$。 由该点引申的性质：<ul><li>深度为h的二叉树，最多有$2^h-1$个节点</li><li>具有n个节点的满二叉树，深度为$\log_2^{n + 1}$</li><li>包含n个节点的二叉树，高度至少为$[\log_2^{n+1}]$，[ ]为向下取整</li></ul></li><li>完全二叉树，从上到下从左到右依次编号。若某节点编号为k，则其左右子树根节点编号分别为2k和2k + 1（证明提示，每一行的起点的编号为$2^{i - 1}$）</li></ol><h2 id="4-遍历二叉树"><a href="#4-遍历二叉树" class="headerlink" title="4. 遍历二叉树"></a>4. 遍历二叉树</h2><blockquote><p>二叉树，有深度遍历和广度遍历。深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们寻常所说的层次遍历。</p><p>由于树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅实现简单并且易于理解。而对于广度遍历来说，须要其他数据结构的支撑，比如堆。</p></blockquote><h3 id="4-1-前序遍历："><a href="#4-1-前序遍历：" class="headerlink" title="4.1 前序遍历："></a>4.1 前序遍历：</h3><blockquote><ol><li>访问根节点</li><li>前序遍历左子树</li><li>前序遍历右子树</li></ol></blockquote><p><img src="../../images/20180223122131558.png" alt="20180223122131558"></p><h3 id="4-2-中序遍历："><a href="#4-2-中序遍历：" class="headerlink" title="4.2 中序遍历："></a>4.2 中序遍历：</h3><blockquote><ol><li>中序遍历左子树</li><li>访问根节点</li><li>中序遍历右子树</li></ol></blockquote><p><img src="../../images/20180223122302320.png" alt="20180223122302320"></p><h3 id="4-3-后序遍历："><a href="#4-3-后序遍历：" class="headerlink" title="4.3 后序遍历："></a>4.3 后序遍历：</h3><blockquote><ol><li>后续遍历左子树</li><li>后续遍历右子树</li><li>访问根节点</li></ol></blockquote><p><img src="../../images/20180223122410506.png" alt="20180223122410506"></p><h3 id="4-4-层序遍历："><a href="#4-4-层序遍历：" class="headerlink" title="4.4 层序遍历："></a>4.4 层序遍历：</h3><blockquote><p>从上到下，从左到右，依次访问</p></blockquote><p><img src="../../images/Screen Shot 2018-12-10 at 10.30.03 PM.png" alt="Screen Shot 2018-12-10 at 10.30.03 PM"></p><hr><h2 id="更新历史"><a href="#更新历史" class="headerlink" title="更新历史"></a>更新历史</h2><ul><li>2018-12-21：更新二叉搜索树、平衡二叉树。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 85</title>
      <link href="/leetcode/leetcode-85/"/>
      <url>/leetcode/leetcode-85/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>给定一个只包含0和1的二维数组，找到只包含1的最大矩形。</p><p>例子：</p><pre class=" language-python"><code class="language-python">Input<span class="token punctuation">:</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"0"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"0"</span><span class="token punctuation">,</span><span class="token string">"0"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"0"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"0"</span><span class="token punctuation">,</span><span class="token string">"0"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"0"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>Output<span class="token punctuation">:</span> <span class="token number">6</span></code></pre><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="1-动态规划："><a href="#1-动态规划：" class="headerlink" title="1. 动态规划："></a>1. 动态规划：</h3><p>这道题可以用动态规划的方法来解决。对于矩阵中的每个为1的点，以该点为起点向上连一条最长的只包含1的直线。求出包含该直线最大的矩形的面积。所有面积中最大的即为所求。以下图为例，红色点对应的面积即为绿色框所显示的区域。</p><p><img src="../../images/leetcode 85.jpg" alt="leetcode 85"></p><p>为了实现上面的思路，我们只需要维护三个标记为left、right、hight的矩阵。面积即为hight * (right - left)。</p><blockquote><p>[cur_left, cur_right)     // 当前行包含该点最长的连续1区间</p><p>left(i, j) = max(left(i-1, j),  cur_left)</p><p>right(i, j) = min(right(i-1, j), cur_right) </p><p>height(i, j) += 1, if matrix[i][j]==’1’; </p><p>height(i, j) = 0, if matrix[i][j]==’0’</p></blockquote><p>以上面的例子为例，最终left、right、hight三个矩阵分别为：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># left</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># right</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># height</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span></code></pre><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maximalRectangle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type matrix: List[List[str]]        :rtype: int        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> matrix<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># DP</span>        m<span class="token punctuation">,</span> n <span class="token operator">=</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        left <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        right <span class="token operator">=</span> <span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">*</span> n        hight <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        max_area <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># left</span>            curr_left<span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">:</span>                    left<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>curr_left<span class="token punctuation">,</span> left<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    left<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>                    curr_left <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># right</span>            curr_right <span class="token operator">=</span> n            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">:</span>                    right<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>curr_right<span class="token punctuation">,</span> right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    right<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> n                    curr_right <span class="token operator">=</span> j            <span class="token comment" spellcheck="true"># hight</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">:</span>                    hight<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    hight<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            <span class="token comment" spellcheck="true"># area</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                curr_area <span class="token operator">=</span> <span class="token punctuation">(</span>right<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> left<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> hight<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                max_area <span class="token operator">=</span> max<span class="token punctuation">(</span>max_area<span class="token punctuation">,</span> curr_area<span class="token punctuation">)</span>        <span class="token keyword">return</span> max_area</code></pre><h3 id="2-基于LeetCode-84题的O-n-2-解法"><a href="#2-基于LeetCode-84题的O-n-2-解法" class="headerlink" title="2. 基于LeetCode 84题的O(n^2)解法"></a>2. 基于LeetCode 84题的O(n^2)解法</h3><p>对于每一行构造出以当前行为底的柱状图，然后利用LeetCode 84题的解法，对每一行求解。最终求出最大的矩形。以下图为例，对于红色行，构造的柱形图即为绿色框所围起来的。</p><p><img src="../../images/LeetCode85_1.jpg" alt="LeetCode85_1"></p><h4 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maximalRectangle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type matrix: List[List[str]]        :rtype: int        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> matrix<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        m<span class="token punctuation">,</span> n <span class="token operator">=</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        height <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        ans <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">:</span>                    height<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    height<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            <span class="token comment" spellcheck="true"># solution for LeetCode 84</span>            stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> height<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> height<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    h <span class="token operator">=</span> height<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>                    w <span class="token operator">=</span> j <span class="token operator">-</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span>                    ans <span class="token operator">=</span> max<span class="token punctuation">(</span>ans<span class="token punctuation">,</span> w <span class="token operator">*</span> h<span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>j<span class="token punctuation">)</span>        <span class="token keyword">return</span> ans</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何修改Hexo主题</title>
      <link href="/ruan-jian/ru-he-xiu-gai-hexo-zhu-ti/"/>
      <url>/ruan-jian/ru-he-xiu-gai-hexo-zhu-ti/</url>
      
        <content type="html"><![CDATA[<p>这几天使用hexo-theme-matery的主题搭建Blog时，发现主题的很多设计不是很喜欢。所以就想自己动手改一下，于是也就有了这篇博客。在讲修改之前先说一下如果你和我一样也是0基础，却想要修改别人的主题，要做哪些准备。</p><h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><p>我们想要展示一个blog，所有的工作最终都是为了要生成html的网页文件。所以我们需要学习一点html的概念。</p><p>HTML 是用来描述网页的一种语言。是一种标记语言。css定义了网页的样式，而js定义了网页的行为。</p><p>你可以通过下面的链接，快速学习一下 html、css 和 js：</p><ul><li><a href="http://www.runoob.com/html/html-intro.html" target="_blank" rel="noopener">菜鸟教程 | HTML</a></li><li><a href="http://www.runoob.com/css/css-tutorial.html" target="_blank" rel="noopener">菜鸟教程 | CSS</a></li><li><a href="http://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noopener">菜鸟教程| JavaScript</a></li></ul><p>这里我把一些很关键的点列出来。这样就算你不去学习上面的教程也能够了解到大致的原理。</p><h3 id="HTML知识点："><a href="#HTML知识点：" class="headerlink" title="HTML知识点："></a>HTML知识点：</h3><h4 id="1-HTML网页结构"><a href="#1-HTML网页结构" class="headerlink" title="1. HTML网页结构"></a>1. HTML网页结构</h4><p><img src="../../images/html网页结构.jpg" alt="html网页结构"></p><p>所以这就是为什么会看到很多教程说把此段代码添加到head内。</p><h4 id="2-网页的布局"><a href="#2-网页的布局" class="headerlink" title="2. 网页的布局"></a>2. 网页的布局</h4><p><img src="../../images/img_sem_elements.gif" alt="img_sem_elements"></p><p>很多主题都通过定义以下HTML代码：&lt;div id=”nav”&gt;、&lt;div class=”header”&gt; 或者 &lt;div id=”footer”&gt; 来指明导航链接、头部以及尾部。当你想要修改哪些部分时，首先尝试去寻找对应区域的关键词，迅速定位要修改代码的位置。</p><h4 id="3-HTML速查列表"><a href="#3-HTML速查列表" class="headerlink" title="3. HTML速查列表"></a>3. HTML速查列表</h4><p>当你大致了解了HTML之后。这里有一份HTML的速查列表，你可以打印它，已备日常使用：</p><p><a href="http://www.runoob.com/html/html-quicklist.html" target="_blank" rel="noopener">菜鸟教程 | HTML 速查列表</a></p><h3 id="CSS知识点："><a href="#CSS知识点：" class="headerlink" title="CSS知识点："></a>CSS知识点：</h3><h4 id="1-CSS-语法"><a href="#1-CSS-语法" class="headerlink" title="1. CSS 语法"></a>1. CSS 语法</h4><p>css定义了HTML中的元素的样式。CSS规则主要由两部分组成：选择器，以及一条或者多条声明构成：</p><p><img src="../../images/632877C9-2462-41D6-BD0E-F7317E4C42AC.jpg" alt="632877C9-2462-41D6-BD0E-F7317E4C42AC"></p><p>选择器通常是你想要修改样式的 HTML 元素，声明则是你要修改属性和样式。</p><h4 id="2-选择器"><a href="#2-选择器" class="headerlink" title="2. 选择器"></a>2. 选择器</h4><p>选择器分为两种：</p><ul><li>ID选择器：以 “#” 来定义</li><li>class选择器： 以 “.”来定义</li></ul><p>以下的样式规则应用于元素属性 id=”para1”:</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token id">#para1</span></span><span class="token punctuation">{</span>    <span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在以下的例子中，所有拥有 center 类的 HTML 元素均为居中。</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.center</span> </span><span class="token punctuation">{</span>    <span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>选择器支持嵌套，在以下的例子中，card类中所有 center 类的 HTML 元素均为居中</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.card</span> <span class="token class">.center</span> </span><span class="token punctuation">{</span>    <span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>还有一种情况，即多个元素用同样的格式，此时用逗号分隔即可。</p><h4 id="3-CSS-实例"><a href="#3-CSS-实例" class="headerlink" title="3. CSS 实例"></a>3. CSS 实例</h4><p>下面有链接里有很多实例，通过实例可以更快的了解css、js、html是如何一起工作的。</p><p><a href="http://www.runoob.com/css/css-examples.html" target="_blank" rel="noopener">菜鸟教程 | CSS实例</a></p><h3 id="JS知识点："><a href="#JS知识点：" class="headerlink" title="JS知识点："></a>JS知识点：</h3><p>通过上面的js的教程，你会发现 js和 c的语法真的很像。所以如果你会c的语法，那么基本上可以看懂js的代码。</p><p>下面重点说一下ejs，因为我用的主题就使用的ejs。</p><h4 id="1-什么是ejs？"><a href="#1-什么是ejs？" class="headerlink" title="1. 什么是ejs？"></a>1. 什么是ejs？</h4><p>EJS 是一套简单的模板语言，帮你利用普通的 JavaScript 代码生成 HTML 页面。EJS 没有如何组织内容的教条；也没有再造一套迭代和控制流语法；有的只是普通的 JavaScript 代码而已。这是<a href="https://ejs.bootcss.com" target="_blank" rel="noopener">官网</a>给出的介绍。下面只列举出一些知识点，教程可以在官网上看见。</p><h4 id="2-ejs标签含义："><a href="#2-ejs标签含义：" class="headerlink" title="2. ejs标签含义："></a>2. ejs标签含义：</h4><ul><li><code>&lt;%</code> ‘脚本’ 标签，用于流程控制，无输出。</li><li><code>&lt;%_</code> 删除其前面的空格符</li><li><code>&lt;%=</code> 输出数据到模板（输出是转义 HTML 标签）</li><li><code>&lt;%-</code> 输出非转义的数据到模板</li><li><code>&lt;%#</code> 注释标签，不执行、不输出内容</li><li><code>&lt;%%</code> 输出字符串 ‘&lt;%’</li><li><code>%&gt;</code> 一般结束标签</li><li><code>-%&gt;</code> 删除紧随其后的换行符</li><li><code>_%&gt;</code> 将结束标签后面的空格符删除</li></ul><h4 id="3-引入其他模版"><a href="#3-引入其他模版" class="headerlink" title="3. 引入其他模版"></a>3. 引入其他模版</h4><p>比如下面的代码就是将”article/list.ejs” 文件载入到当前ejs里，并传递参数count、page、list。</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">include</span><span class="token punctuation">(</span><span class="token string">"article/list"</span><span class="token punctuation">,</span><span class="token punctuation">{</span>    count <span class="token punctuation">:</span> locals<span class="token punctuation">.</span>count<span class="token punctuation">,</span>    page <span class="token punctuation">:</span> locals<span class="token punctuation">.</span>page<span class="token punctuation">,</span>    list <span class="token punctuation">:</span> locals<span class="token punctuation">.</span>list<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token operator">></span></code></pre><hr><p>有了以上这些准备工作就基本完事了。现在你就可以去看theme中的代码了，迅速定位到要修改的位置，然后在网上找到想用的样式。修改或添加相应的代码即可。</p><h5 id="文中主要链接整理如下，以便查阅："><a href="#文中主要链接整理如下，以便查阅：" class="headerlink" title="文中主要链接整理如下，以便查阅："></a>文中主要链接整理如下，以便查阅：</h5><ul><li><a href="http://www.runoob.com/html/html-intro.html" target="_blank" rel="noopener">菜鸟教程 | HTML</a></li><li><a href="http://www.runoob.com/css/css-tutorial.html" target="_blank" rel="noopener">菜鸟教程 | CSS</a></li><li><a href="http://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noopener">菜鸟教程| JavaScript</a></li><li><a href="http://www.runoob.com/html/html-quicklist.html" target="_blank" rel="noopener">菜鸟教程 | HTML 速查列表</a></li><li><a href="http://www.runoob.com/css/css-examples.html" target="_blank" rel="noopener">菜鸟教程 | CSS实例</a></li><li><a href="https://ejs.bootcss.com" target="_blank" rel="noopener">EJS 官网</a></li></ul><p>今天先写到这里。之后我会讲一下，对于hexo-theme-matery主题，我做了哪些修改，供大家参考。以上如果有不正确或不清楚的地方，欢迎指正。</p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于Docker的Hexo博客搭建</title>
      <link href="/ruan-jian/ji-yu-docker-de-hexo-bo-ke-da-jian/"/>
      <url>/ruan-jian/ji-yu-docker-de-hexo-bo-ke-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-准备知识"><a href="#1-准备知识" class="headerlink" title="1. 准备知识"></a>1. 准备知识</h2><p>首先我们需要先了解一下docker的常用命令和hexo的常用命令</p><h5 id="Docker准备知识："><a href="#Docker准备知识：" class="headerlink" title="Docker准备知识："></a>Docker准备知识：</h5><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ****************************** 容器 ****************************** #</span><span class="token comment" spellcheck="true"># 查看正在运行的容器</span>$ docker <span class="token function">ps</span><span class="token comment" spellcheck="true"># 查看所有容器</span>$ docker <span class="token function">ps</span> -a<span class="token comment" spellcheck="true"># 启动/停止某个容器</span>$ docker start/stop id/name<span class="token comment" spellcheck="true"># 以交互方式启动一个容器</span>$ docker start -i id/name<span class="token comment" spellcheck="true"># 进入某个容器(使用exit退出后容器也跟着停止运行)</span>$ docker attach id/name<span class="token comment" spellcheck="true"># 启动一个伪终端以交互式的方式进入某个运行的容器（使用exit退出后容器不停止运行）</span>$ docker <span class="token function">exec</span> -it id/name<span class="token comment" spellcheck="true"># 删除某个容器</span>$ docker <span class="token function">rm</span> id/name<span class="token comment" spellcheck="true"># 复制ubuntu容器并且重命名为test且运行，然后以伪终端交互式方式进入容器，运行bash</span>$ docker run --name <span class="token function">test</span> -ti ubuntu /bin/bash<span class="token comment" spellcheck="true"># ****************************** 镜像 ****************************** #</span><span class="token comment" spellcheck="true"># 查看本地镜像</span>$ docker images<span class="token comment" spellcheck="true"># 删除某个镜像</span>$ docker rmi id/name<span class="token comment" spellcheck="true"># 基于当前目录下的Dockerfile，创建一个名为name:flag的镜像</span>$ docker build -t name:flag <span class="token keyword">.</span></code></pre><p>你可能还需要了解一点Docker Compose的知识：</p><blockquote><p>Docker Compose 是 Docker 容器进行编排的工具，定义和运行多容器的应用，可以一条命令启动多个容器。</p><p>使用Compose 基本上分为三步：</p><ol><li>Dockerfile 定义应用的运行环境</li><li>docker-compose.yml 定义组成应用的各服务</li><li>docker-compose up -d 启动整个应用</li><li>docker-compose down 停止整个应用</li></ol></blockquote><p>官方文档：</p><ol><li><a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener">Get started with Docker</a></li><li><a href="https://docs.docker.com/compose/gettingstarted/" target="_blank" rel="noopener">Get started with Docker Compose</a></li></ol><h5 id="Hexo准备知识："><a href="#Hexo准备知识：" class="headerlink" title="Hexo准备知识："></a>Hexo准备知识：</h5><p>hexo的安装和使用非常简单，官网给出的教程如下，前提是你已经有了一个node的环境。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo-cli -g$ hexo init blog$ <span class="token function">cd</span> blog$ <span class="token function">npm</span> <span class="token function">install</span>$ hexo server</code></pre><h2 id="2-使用Docker搭建一个hexo环境"><a href="#2-使用Docker搭建一个hexo环境" class="headerlink" title="2. 使用Docker搭建一个hexo环境"></a>2. 使用Docker搭建一个hexo环境</h2><p>首先下载并安装社区版本<a href="https://www.docker.com/get-started" target="_blank" rel="noopener">Docker CE</a>。安装好后，你就可以在终端中调用Docker的指令了。我们先拉取一个node镜像。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 由于目前hexo不支持最新的 node11.3.0 所以选用node长期支持版10.14.1</span>$ docker pull node:10</code></pre><p>创建你博客的工作目录，这里我们以 “~/Hexo” 为例：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">mkdir</span> -p ~/Hexo <span class="token operator">&amp;&amp;</span> <span class="token function">cd</span> ~/Hexo<span class="token comment" spellcheck="true"># 创建存放Dockerfile的文件夹</span>$ <span class="token function">mkdir</span> hexo_docker <span class="token operator">&amp;&amp;</span> <span class="token function">cd</span> hexo_docker<span class="token comment" spellcheck="true"># 创建Dockerfile</span>$ <span class="token function">touch</span> Dockerfile</code></pre><p>Dockerfile文件内容如下：</p><pre class=" language-docker"><code class="language-docker"><span class="token comment" spellcheck="true"># *****************************************************************************</span><span class="token comment" spellcheck="true"># File Name: Dockerfile</span><span class="token comment" spellcheck="true"># Auther: Chuncheng Wei</span><span class="token comment" spellcheck="true"># Email: weicc1989@gmail.com</span><span class="token comment" spellcheck="true"># Created Time: Fri Nov 30 23:08:07 2018</span><span class="token comment" spellcheck="true"># Description:</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#     This bases on node:10 image</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># *****************************************************************************</span><span class="token comment" spellcheck="true"># 基础镜像</span><span class="token keyword">FROM</span> node<span class="token punctuation">:</span>10<span class="token comment" spellcheck="true"># 维护者信息</span><span class="token keyword">MAINTAINER</span> your_name &lt;your_mail<span class="token punctuation">></span><span class="token comment" spellcheck="true"># 工作目录</span><span class="token keyword">WORKDIR</span> /hexo<span class="token comment" spellcheck="true"># 安装Hexo</span><span class="token keyword">RUN</span> npm install hexo<span class="token punctuation">-</span>cli <span class="token punctuation">-</span>g<span class="token keyword">RUN</span> hexo init .<span class="token keyword">RUN</span> npm install<span class="token comment" spellcheck="true"># 设置git</span><span class="token keyword">RUN</span> git config <span class="token punctuation">-</span><span class="token punctuation">-</span>global user.name <span class="token string">"your_name"</span><span class="token keyword">RUN</span> git config <span class="token punctuation">-</span><span class="token punctuation">-</span>global user.email <span class="token string">"your_mail"</span><span class="token comment" spellcheck="true"># 映射端口</span><span class="token keyword">EXPOSE</span> 4000<span class="token comment" spellcheck="true"># 运行命令</span><span class="token keyword">CMD</span> <span class="token punctuation">[</span><span class="token string">"/bin/bash"</span><span class="token punctuation">]</span></code></pre><p>基于Docker文件创建 hexo:10 镜像：</p><pre class=" language-bash"><code class="language-bash">$ docker build -t <span class="token string">'hexo:10'</span> <span class="token keyword">.</span></code></pre><p>此时，我们就有了一个可以折腾hexo镜像了，而且在镜像的/hexo目录下我们也已经初始化好了hexo博客的环境。执行下面的命令，我们就可以看到目前拥有的docker镜像了。</p><pre class=" language-bash"><code class="language-bash">$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEhexo                10                  3cae20f1d074        8 seconds ago       1.01GBnode                10                  d330537fea0f        5 days ago          893MB</code></pre><p>此时我们就可以看下初步的效果了，在终端中使用镜像hexo:10以交互模式启动一个容器，将容器的 4000 端口映射到主机的 4000 端口，主机的目录 $HOME/.ssh 映射到容器的 /root/.ssh，并在容器内执行 /bin/bash 命令。</p><pre class=" language-bash"><code class="language-bash">$ docker run -it --name<span class="token operator">=</span><span class="token string">"temp"</span> -p 4000:4000 -v <span class="token variable">$HOME</span>/.ssh:/root/.ssh hexo:10 /bin/bash<span class="token comment" spellcheck="true"># 会进入容器的bash环境，显示如下。@后面的一串数字和字母是容器的id</span>root@b3f600327b99:/hexo<span class="token comment" spellcheck="true">#</span></code></pre><p>在这个环境下执行 hexo s 然后用本地浏览器打开：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 即可预览你的博客了。显示如下：</p><pre class=" language-bash"><code class="language-bash">root@b3f600327b99:/hexo<span class="token comment" spellcheck="true"># hexo s</span>INFO  Start processingINFO  Hexo is running at http://localhost:4000 <span class="token keyword">.</span> Press Ctrl+C to stop.</code></pre><p><img src="../../images/hexo.jpg" alt="hexo"></p><h2 id="3-使用hexo-theme-matery主题"><a href="#3-使用hexo-theme-matery主题" class="headerlink" title="3. 使用hexo-theme-matery主题"></a>3. 使用hexo-theme-matery主题</h2><p>此时我们只搭好了一个hexo的基础环境。接下来我们制作一个使用hexo-theme-matery的docker镜像。</p><p>主题的下载地址为：</p><p><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">https://github.com/blinkfox/hexo-theme-matery</a></p><p>主题的说明文档：</p><p><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p><p>主题主要依赖的npm包如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 代码高亮</span>$ <span class="token function">npm</span> i -S hexo-prism-plugin<span class="token comment" spellcheck="true"># 搜索</span>$ <span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search --save<span class="token comment" spellcheck="true"># 中文链接转拼音（可选的）</span>$ <span class="token function">npm</span> i hexo-permalink-pinyin --save<span class="token comment" spellcheck="true"># 添加RSS订阅支持（可选的）</span>$ <span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed --save</code></pre><p>下面我们介绍两种搭建方法，一种搭建简单，但工作目录比较复杂。另一种搭建繁琐，但目录结构简单。</p><p>简单方法搭建好后目录如下：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">ls</span>_config.yml  docker-compose.yml  node_modules       package.json  scaffolds  themesdb.json      hexo_docker         package-lock.json  public        <span class="token function">source</span>     yarn.lock</code></pre><p>复杂方法搭建好后目录如下：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">ls</span>_config.yml  docker-compose.yml  hexo_docker  scaffolds  <span class="token function">source</span>  themes</code></pre><h3 id="A-简单搭建方法："><a href="#A-简单搭建方法：" class="headerlink" title="A. 简单搭建方法："></a>A. 简单搭建方法：</h3><p>以最终工作目录为 ~/Blog 为例：</p><h4 id="创建新镜像"><a href="#创建新镜像" class="headerlink" title="创建新镜像"></a>创建新镜像</h4><p>首先创建用于创建新镜像的Dockerfile文件，文件命名为Dockerfile_matery</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> ~/Hexo/hexo_docker$ <span class="token function">touch</span> Dockerfile_matery</code></pre><p>Dockerfile_matery 内容如下：</p><pre class=" language-docker"><code class="language-docker"><span class="token comment" spellcheck="true"># *****************************************************************************</span><span class="token comment" spellcheck="true"># File Name: Dockerfile_matery</span><span class="token comment" spellcheck="true"># Auther: Chuncheng Wei</span><span class="token comment" spellcheck="true"># Email: weicc1989@gmail.com</span><span class="token comment" spellcheck="true"># Created Time: Fri Nov 30 23:08:07 2018</span><span class="token comment" spellcheck="true"># Description:</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#     This bases on node:10 image</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># *****************************************************************************</span><span class="token comment" spellcheck="true"># 基础镜像</span><span class="token keyword">FROM</span> hexo<span class="token punctuation">:</span>10<span class="token comment" spellcheck="true"># 维护者信息</span><span class="token keyword">MAINTAINER</span> your_name &lt;your_mail<span class="token punctuation">></span><span class="token comment" spellcheck="true"># 工作目录</span><span class="token keyword">WORKDIR</span> /hexo<span class="token comment" spellcheck="true"># 安装Hexo插件</span><span class="token keyword">RUN</span> npm i <span class="token punctuation">-</span>S hexo<span class="token punctuation">-</span>prism<span class="token punctuation">-</span>plugin<span class="token keyword">RUN</span> npm install hexo<span class="token punctuation">-</span>generator<span class="token punctuation">-</span>search <span class="token punctuation">-</span><span class="token punctuation">-</span>save<span class="token keyword">RUN</span> npm i hexo<span class="token punctuation">-</span>permalink<span class="token punctuation">-</span>pinyin <span class="token punctuation">-</span><span class="token punctuation">-</span>save<span class="token keyword">RUN</span> npm install hexo<span class="token punctuation">-</span>generator<span class="token punctuation">-</span>feed <span class="token punctuation">-</span><span class="token punctuation">-</span>save<span class="token keyword">RUN</span> npm install hexo<span class="token punctuation">-</span>deployer<span class="token punctuation">-</span>git <span class="token punctuation">-</span><span class="token punctuation">-</span>save<span class="token comment" spellcheck="true"># 映射端口</span><span class="token keyword">EXPOSE</span> 4000<span class="token comment" spellcheck="true"># 运行命令</span><span class="token keyword">CMD</span> <span class="token punctuation">[</span><span class="token string">"/usr/bin/env"</span><span class="token punctuation">,</span> <span class="token string">"hexo"</span><span class="token punctuation">,</span> <span class="token string">"server"</span><span class="token punctuation">]</span></code></pre><p>创建镜像和容器</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> ~/Hexo<span class="token comment" spellcheck="true"># 创建镜像</span>$ docker build -t <span class="token string">'temp:10'</span> -f Dockerfile_matery ./hexo_docker<span class="token comment" spellcheck="true"># 创建容器并启动</span>$ docker run -it --name<span class="token operator">=</span><span class="token string">"simple"</span> -p 4000:4000 -v <span class="token variable">$HOME</span>/.ssh:/root/.ssh -v <span class="token variable">$PWD</span>/simple:/hexo temp:10 /bin/bash</code></pre><h4 id="启动容器，并设置主题"><a href="#启动容器，并设置主题" class="headerlink" title="启动容器，并设置主题"></a>启动容器，并设置主题</h4><p>进入容器后，初始化hexo博客</p><pre class=" language-bash"><code class="language-bash">$ hexo init <span class="token keyword">.</span></code></pre><p>另开一个终端，下载<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">hexo-theme-matery</a>主题，并按<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">说明文档</a>设置。</p><p>切回到容器终端，就可以执行各种hexo的指令了。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 生成静态网页，并布置到网站上，前提设置好_config.yml文件中的deploy参数</span>$ hexo g -d<span class="token comment" spellcheck="true"># 本地访问http://localhost:4000预览</span>$ hexo s</code></pre><p>下次重启容器只需要输入下面指令即可：</p><pre class=" language-bash"><code class="language-bash">$ docker start -i simple</code></pre><hr><h4 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h4><p>此时简单方法的搭建已经完成。这种方法的好处就是简单，而且可以随时在容器中执行操作。跟本地环境几乎没区别。很方便。如果你觉得每次启动容器后还要输入命令，比较麻烦。那么就可以参照下面的教程写一个docker 的服务文件，即docker-compose.yml：</p><p>把相关文件都整合到simple目录下：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cp</span> -r ~/Hexo/hexo_docker ~/Hexo/simple$ <span class="token function">cd</span> ~/Hexo/simple$ <span class="token function">touch</span> docker-compose.yml</code></pre><p>docker-compose.yml文件：</p><pre class=" language-docker"><code class="language-docker">version<span class="token punctuation">:</span> <span class="token string">'3'</span>services<span class="token punctuation">:</span>  blog<span class="token punctuation">:</span>    restart<span class="token punctuation">:</span> always    build<span class="token punctuation">:</span>        context<span class="token punctuation">:</span> hexo_docker        dockerfile<span class="token punctuation">:</span> Dockerfile_matery    image<span class="token punctuation">:</span> temp<span class="token punctuation">:</span>10    container_name<span class="token punctuation">:</span> temp_simple    ports<span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"4000:4000"</span>    volumes<span class="token punctuation">:</span>     <span class="token punctuation">-</span> $HOME/.ssh<span class="token punctuation">:</span>/root/.ssh     <span class="token punctuation">-</span> $PWD<span class="token punctuation">:</span>/hexo</code></pre><p>这样启动服务时，容器就自动执行Dockerfile中写好的CMD指令，即hexo serve。启动和关闭服务如下：</p><pre class=" language-bash"><code class="language-bash">$ docker-compose up -d     <span class="token comment" spellcheck="true"># 启动整个应用</span>$ docker-compose down     <span class="token comment" spellcheck="true"># 停止整个应用</span></code></pre><h3 id="B-复杂搭建方法"><a href="#B-复杂搭建方法" class="headerlink" title="B. 复杂搭建方法"></a>B. 复杂搭建方法</h3><p>为了尽量简化博客目录，我们可以把不相关的文件保存在Docker镜像里。在博客目录只保留内容相关的文件。</p><p>首先我们先列出需要保留的目录和文件：</p><ul><li>docker相关：<ul><li>docker-compose.yml    服务配置文件</li><li>hexo_docker/    用于存放Dockerfile文件</li></ul></li><li>hexo相关：<ul><li>scaffolds/    存放模版文件</li><li>source/        存放用户资源文件，post，draft</li><li>themes/      存放主题</li></ul></li><li>git相关：<ul><li>.deploy_git/    hexo-deployer-git插件用于存放commit历史记录。</li></ul></li></ul><p>其中.deploy_git/目录如果不保留在本地会导致每次都重新commit全部文件导致远程的库会越来越大。</p><p>简化目录的思路就是把上述文件留在本地然后每次启动应用时挂在到容器内部即可。这里我们以目录~/hexo/complex为例，讲述搭过程：</p><h4 id="筹备工作（将上述文件复制到complex目录）："><a href="#筹备工作（将上述文件复制到complex目录）：" class="headerlink" title="筹备工作（将上述文件复制到complex目录）："></a>筹备工作（将上述文件复制到complex目录）：</h4><pre class=" language-bash"><code class="language-bash">$ <span class="token function">mkdir</span> -p ~/hexo/complex$ <span class="token function">cd</span> ~/hexo/simple$ <span class="token function">cp</span> -r _config.yml docker-compose.yml hexo_docker scaffolds <span class="token function">source</span> themes .deploy_git/ <span class="token punctuation">..</span>/complex$ <span class="token function">cd</span> ~/hexo/complex</code></pre><p>当然你也可以通过其他的方式获得上述文件复制到complex文件夹即可。</p><h4 id="修改Dockerfile-matery文件："><a href="#修改Dockerfile-matery文件：" class="headerlink" title="修改Dockerfile_matery文件："></a>修改Dockerfile_matery文件：</h4><pre class=" language-docker"><code class="language-docker"><span class="token comment" spellcheck="true"># 基础镜像</span><span class="token keyword">FROM</span> hexo<span class="token punctuation">:</span>10<span class="token comment" spellcheck="true"># 维护者信息</span><span class="token keyword">MAINTAINER</span> your_name &lt;your_mail<span class="token punctuation">></span><span class="token comment" spellcheck="true"># 工作目录</span><span class="token keyword">WORKDIR</span> /hexo<span class="token comment" spellcheck="true"># 安装Hexo插件</span><span class="token keyword">RUN</span> npm i <span class="token punctuation">-</span>S hexo<span class="token punctuation">-</span>prism<span class="token punctuation">-</span>plugin<span class="token keyword">RUN</span> npm install hexo<span class="token punctuation">-</span>generator<span class="token punctuation">-</span>search <span class="token punctuation">-</span><span class="token punctuation">-</span>save<span class="token keyword">RUN</span> npm i hexo<span class="token punctuation">-</span>permalink<span class="token punctuation">-</span>pinyin <span class="token punctuation">-</span><span class="token punctuation">-</span>save<span class="token keyword">RUN</span> npm install hexo<span class="token punctuation">-</span>generator<span class="token punctuation">-</span>feed <span class="token punctuation">-</span><span class="token punctuation">-</span>save<span class="token keyword">RUN</span> npm install hexo<span class="token punctuation">-</span>deployer<span class="token punctuation">-</span>git <span class="token punctuation">-</span><span class="token punctuation">-</span>save<span class="token comment" spellcheck="true"># 挂载volume</span><span class="token keyword">VOLUME</span> <span class="token punctuation">[</span><span class="token string">"/hexo/.deploy_git"</span><span class="token punctuation">,</span> <span class="token string">"/hexo/scaffolds"</span><span class="token punctuation">,</span> <span class="token string">"/hexo/source"</span><span class="token punctuation">,</span> <span class="token string">"/hexo/themes"</span><span class="token punctuation">,</span> <span class="token string">"/root/.ssh"</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 映射端口</span><span class="token keyword">EXPOSE</span> 4000<span class="token comment" spellcheck="true"># 运行命令</span><span class="token keyword">CMD</span> <span class="token punctuation">[</span><span class="token string">"/usr/bin/env"</span><span class="token punctuation">,</span> <span class="token string">"hexo"</span><span class="token punctuation">,</span> <span class="token string">"server"</span><span class="token punctuation">]</span></code></pre><p>与simple的相比只是添加挂载volume一项。</p><h4 id="修改docker-compose-yml文件"><a href="#修改docker-compose-yml文件" class="headerlink" title="修改docker-compose.yml文件"></a>修改docker-compose.yml文件</h4><pre class=" language-docker"><code class="language-docker">version<span class="token punctuation">:</span> <span class="token string">'3'</span>services<span class="token punctuation">:</span>  blog<span class="token punctuation">:</span>    restart<span class="token punctuation">:</span> always    build<span class="token punctuation">:</span>        context<span class="token punctuation">:</span> hexo_docker        dockerfile<span class="token punctuation">:</span> Dockerfile_matery    image<span class="token punctuation">:</span> blog<span class="token punctuation">:</span>matery    container_name<span class="token punctuation">:</span> blog    ports<span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"4000:4000"</span>    volumes<span class="token punctuation">:</span>     <span class="token punctuation">-</span> $HOME/.ssh<span class="token punctuation">:</span>/root/.ssh     <span class="token punctuation">-</span> $PWD/.deploy_git<span class="token punctuation">:</span>/hexo/.deploy_git     <span class="token punctuation">-</span> $PWD/scaffolds<span class="token punctuation">:</span>/hexo/scaffolds     <span class="token punctuation">-</span> $PWD/source<span class="token punctuation">:</span>/hexo/source     <span class="token punctuation">-</span> $PWD/themes<span class="token punctuation">:</span>/hexo/themes     <span class="token punctuation">-</span> $PWD/_config.yml<span class="token punctuation">:</span>/hexo/_config.yml</code></pre><p>同样也只是把本地文件挂载到容器中。</p><p>此时就已经完成了，运行方法如下：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> ~/hexo/complex<span class="token comment" spellcheck="true"># 启动应用，此时即可访问http://localhost:4000 查看效果</span>$ docker-compose up -d<span class="token comment" spellcheck="true"># 创建新post</span>$ docker <span class="token function">exec</span> blog hexo new post <span class="token string">"your_post_name"</span><span class="token comment" spellcheck="true"># 生成静态网页并发布</span>$ docker <span class="token function">exec</span> blog hexo g -d<span class="token comment" spellcheck="true"># 停止应用</span>$ docker-compose down</code></pre><p>任何hexo的指令都可以通过前面加上docker exec blog来执行。其中blog为容器名。</p><p>当然为了方便也可以在.bashrc中添加如下语句</p><pre class=" language-bash"><code class="language-bash"><span class="token function">alias</span> hexo<span class="token operator">=</span><span class="token string">"docker exec blog hexo"</span></code></pre><p>这样就可以在终端中直接执行 hexo g -d 之类的语句了，而不用加上前面 docker exec blog</p><hr><h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h2><p>至此，整个环境就搭建完了。</p><p>如何建立远程分支将hexo博客的源码和生成的静态文件push到不同的分支上可以参阅：</p><p><a href="https://o--o.win/Website/Hexo_set_branch/" target="_blank" rel="noopener">Hexo建分支Push源文件到仓库</a></p><p>插入图片的问题可以参阅：</p><p><a href="https://o--o.win/Website/HexoPic/" target="_blank" rel="noopener">Hexo插本地图不借助插件和图床</a></p><p>这是个很棒的解决方案。</p><p>以及如何插入jupyer notebook，以及基于原主题的一些修改，我会整理到下一篇博客里。</p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Docker </tag>
            
            <tag> hexo-theme-matery </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>负数求余，Python和C++的不同</title>
      <link href="/ruan-jian/fu-shu-qiu-yu-python-he-c-de-bu-tong/"/>
      <url>/ruan-jian/fu-shu-qiu-yu-python-he-c-de-bu-tong/</url>
      
        <content type="html"><![CDATA[<h5 id="先上例子"><a href="#先上例子" class="headerlink" title="先上例子"></a>先上例子</h5><pre class=" language-python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">3</span> <span class="token operator">%</span> <span class="token number">10</span>Out<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">7</span></code></pre><pre class=" language-cpp"><code class="language-cpp">root <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token number">3</span> <span class="token operator">%</span> <span class="token function">10</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">3</span></code></pre><hr><h2 id="分析原因："><a href="#分析原因：" class="headerlink" title="分析原因："></a>分析原因：</h2><p>在数学公式中，两种语言的求余数的算法都是一样的：</p><blockquote><p>余数 = 被除数 - 除数 * 商</p></blockquote><p>唯一的区别是，整除（即公式中的商）在两种语言中是不同的。</p><ul><li>C：从c99开始规定向0取整</li><li>python：向负无穷取整</li></ul><h5 id="再上个例子："><a href="#再上个例子：" class="headerlink" title="再上个例子："></a>再上个例子：</h5><pre class=" language-python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">3</span> <span class="token operator">//</span> <span class="token number">10</span>Out<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span></code></pre><pre class=" language-cpp"><code class="language-cpp">root <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token number">3</span> <span class="token operator">/</span> <span class="token function">10</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token number">0</span></code></pre><p>将商带入公式，就可以解释为什么第一个例子中两种语言得到不同的余数了。</p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>神经网络动量因子</title>
      <link href="/ai/shen-jing-wang-luo-dong-liang-yin-zi/"/>
      <url>/ai/shen-jing-wang-luo-dong-liang-yin-zi/</url>
      
        <content type="html"><![CDATA[<p>反向传播算法中，学习率 $\eta$ 越小，每次迭代下降的步长越小，轨迹空间越平滑，学习速度越慢，提 $\eta$ 会加快学习速度，但网络权值的变化不稳定。为此，D.E. Rumlhart提出一种，既能加快学习速度，又能保持稳定的改进方法。这种方法是在修改规则中增加一个动量项：</p><p>$$<br>\Delta w(n)=-\eta\frac{\partial E(w)}{\partial w(n)} + a\Delta w(n - 1),\qquad n=1,2,3,…<br>$$<br>其中第一项为常规BP算法修正量，第二项为动量项，$a$ 为动量项系数，一般取 $(0,1)$。</p><p>直观上理解就是当前梯度方向与前一步梯度方向一致则增加权值更新，如果不一致则减小更新。类似于惯性。</p><blockquote><p>参考：<a href="https://blog.csdn.net/bvl10101111/article/details/54973284" target="_blank" rel="noopener">https://blog.csdn.net/bvl10101111/article/details/54973284</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> NN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DataFrame小技巧</title>
      <link href="/ruan-jian/dataframe-xiao-ji-qiao/"/>
      <url>/ruan-jian/dataframe-xiao-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h2 id="1-筛选数据"><a href="#1-筛选数据" class="headerlink" title="1. 筛选数据"></a>1. 筛选数据</h2><p><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.query.html" target="_blank" rel="noopener">DataFrame.query</a>(expr, inplace=False, **kwargs)：通过字符串表达式选取列。<a href="https://stackoverflow.com/questions/15315452/selecting-with-complex-criteria-from-pandas-dataframe" target="_blank" rel="noopener">参考问题</a></p><pre class=" language-python"><code class="language-python">df<span class="token punctuation">.</span>query<span class="token punctuation">(</span><span class="token string">'B > 50 and C != 900'</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 等效于</span>df<span class="token punctuation">[</span><span class="token punctuation">(</span>df<span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>df<span class="token punctuation">[</span><span class="token string">'C'</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">900</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><p><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.isin.html" target="_blank" rel="noopener">pandas.Series.isin</a>(values): or <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.isin.html#pandas-dataframe-isin" target="_blank" rel="noopener">pandas.DataFrame.isin</a>(values):</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'lama'</span><span class="token punctuation">,</span> <span class="token string">'cow'</span><span class="token punctuation">,</span> <span class="token string">'lama'</span><span class="token punctuation">,</span> <span class="token string">'beetle'</span><span class="token punctuation">,</span> <span class="token string">'lama'</span><span class="token punctuation">,</span> <span class="token string">'hippo'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'animal'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>isin<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'cow'</span><span class="token punctuation">,</span> <span class="token string">'lama'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token number">0</span>     <span class="token boolean">True</span><span class="token number">1</span>     <span class="token boolean">True</span><span class="token number">2</span>     <span class="token boolean">True</span><span class="token number">3</span>    <span class="token boolean">False</span><span class="token number">4</span>     <span class="token boolean">True</span><span class="token number">5</span>    <span class="token boolean">False</span>Name<span class="token punctuation">:</span> animal<span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> bool</code></pre><h2 id="2-修改index"><a href="#2-修改index" class="headerlink" title="2. 修改index"></a>2. 修改index</h2><p><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.set_index.html" target="_blank" rel="noopener">DataFrame.set_index</a>(keys, drop=True, append=False, inplace=False, verify_integrity=False)：其中key为列名或者列名列表 。</p><pre class=" language-python"><code class="language-python">df<span class="token punctuation">.</span>set_index<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'year'</span><span class="token punctuation">,</span> <span class="token string">'month'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h2 id="3-画图"><a href="#3-画图" class="headerlink" title="3. 画图"></a>3. 画图</h2><ol><li><p>画barh时，纵坐标逆序：</p><pre class=" language-python"><code class="language-python">df<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>kind<span class="token operator">=</span><span class="token string">'barh'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>invert_yaxis<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java笔记</title>
      <link href="/ruan-jian/java-bi-ji/"/>
      <url>/ruan-jian/java-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>主要参考：</p><ul><li><a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">java教程</a></li></ul><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><h3 id="数据类型和变量："><a href="#数据类型和变量：" class="headerlink" title="数据类型和变量："></a>数据类型和变量：</h3><ul><li>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</li></ul><pre class=" language-Java"><code class="language-Java">(int)23.7 == 23;        (int)-45.89f == -45</code></pre><ul><li>java中默认声明的小数是double类型的，如：</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">4.0</span>         # 正确<span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">4.0</span>         # 报错<span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">4.0f</span>         # 正确        </code></pre><ul><li>变量默认值<ul><li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li><li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li></ul></li></ul><h3 id="修饰符："><a href="#修饰符：" class="headerlink" title="修饰符："></a>修饰符：</h3><h4 id="访问控制修饰符："><a href="#访问控制修饰符：" class="headerlink" title="访问控制修饰符："></a>访问控制修饰符：</h4><ul><li>修饰符</li></ul><table><thead><tr><th></th><th style="text-align:center">当前类</th><th style="text-align:center">同一包内</th><th style="text-align:center">子孙类</th><th style="text-align:center">其他包</th><th style="text-align:center">其他包子孙类</th></tr></thead><tbody><tr><td><code>public</code></td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td><code>protected</code></td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">Y/N（<a href="http://www.runoob.com/java/java-modifier-types.html#protected-desc" target="_blank" rel="noopener">说明</a>）</td></tr><tr><td><code>default</code></td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr><tr><td><code>private</code></td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr></tbody></table><ul><li><p>接口里的变量都隐式声明为 <strong>public static final</strong>，而接口里的方法默认情况下访问权限为 <strong>public</strong>。</p></li><li><p>类和接口不能声明为 <strong>private</strong>。</p></li><li><p><strong>protected</strong>:</p><ul><li>基类的 protected 成员是包内可见的，并且对子类可见；</li><li>若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。</li><li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li></ul></li></ul><h4 id="非访问控制修饰符"><a href="#非访问控制修饰符" class="headerlink" title="非访问控制修饰符"></a>非访问控制修饰符</h4><ul><li><strong>static</strong> 修饰符，用来修饰类方法和类变量。</li><li><strong>final</strong> 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li><li><strong>abstract</strong> 修饰符，用来创建抽象类和抽象方法。<ul><li>如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</li><li>抽象方法不能被声明成 final 和 static。</li><li>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</li><li>抽象方法的声明以分号结尾，例如：<strong>public abstract sample();</strong>。</li></ul></li><li><strong>synchronized</strong>、<strong>transient</strong> 和 <strong>volatile</strong> 修饰符，主要用于线程的编程。<ul><li><strong>synchronized</strong> 关键字声明的方法同一时间只能被一个线程访问。</li><li><strong>Volatilevolatile</strong> 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。<ul><li>使用建议：在两个或者更多的线程访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，不必使用。</li></ul></li><li>Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。<strong>transient</strong>是Java语言的关键字，用来表示一个域不是该对象串行化的一部分。当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。 </li></ul></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li><strong>instanceof</strong>：该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</li></ul><pre class=" language-java"><code class="language-java">String name <span class="token operator">=</span> <span class="token string">"James"</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> result <span class="token operator">=</span> name <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 由于 name 是 String 类型，所以返回真</span></code></pre><ul><li>条件运算符（? : ）顺序：从右到左</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token number">3</span> <span class="token operator">?</span> <span class="token number">4</span> <span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果从左到右结合，即a = (1 ? 2 : 3) ? 4 : 5 = 2 ? 4 : 5 = 4; </span><span class="token comment" spellcheck="true">// 如果从右到左结合，即a = 1 ? 2 : (3 ? 4 : 5) = 1 ? 2 : 4 = 2; </span><span class="token comment" spellcheck="true">// 实际运行int a = 1 ? 2 : 3 ? 4 : 5;得到a=2;即条件运算符是从右到左结合的。</span></code></pre><ul><li>Java 增强 for 循环</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> numbers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">:</span> numbers <span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span> x <span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>switch 语句有如下规则：<ul><li>switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串类型了，同时 case 标签必须为字符串常量或字面量。</li></ul></li></ul><h3 id="Number-amp-Math-类方法"><a href="#Number-amp-Math-类方法" class="headerlink" title="Number &amp; Math 类方法"></a>Number &amp; Math 类方法</h3><p><a href="http://www.runoob.com/java/java-number.html" target="_blank" rel="noopener">http://www.runoob.com/java/java-number.html</a></p><table><thead><tr><th><a href="http://www.runoob.com/java/number-xxxvalue.html" target="_blank" rel="noopener">xxxValue()</a></th><th>将 Number 对象转换为xxx数据类型的值并返回。</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/java/number-compareto.html" target="_blank" rel="noopener">compareTo()</a></td><td>将number对象与参数比较。</td></tr><tr><td><a href="http://www.runoob.com/java/number-equals.html" target="_blank" rel="noopener">equals()</a></td><td>判断number对象是否与参数相等。</td></tr><tr><td><a href="http://www.runoob.com/java/number-valueof.html" target="_blank" rel="noopener">valueOf()</a></td><td>返回一个 Number 对象指定的内置数据类型</td></tr><tr><td><a href="http://www.runoob.com/java/number-tostring.html" target="_blank" rel="noopener">toString()</a></td><td>以字符串形式返回值。</td></tr><tr><td><a href="http://www.runoob.com/java/number-parseInt.html" target="_blank" rel="noopener">parseInt()</a></td><td>将字符串解析为int类型。</td></tr></tbody></table><h3 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h3><ul><li>String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了。如果需要对字符串做很多修改，那么应该选择使用 <a href="http://www.runoob.com/java/java-stringbuffer.html" target="_blank" rel="noopener">StringBuffer &amp; StringBuilder 类</a>。</li><li>格式化数字可以使用 printf() 和 format() 方法。</li><li><a href="http://www.runoob.com/java/java-string.html" target="_blank" rel="noopener">String 类方法</a></li></ul><h3 id="Java-StringBuffer-和-StringBuilder-类"><a href="#Java-StringBuffer-和-StringBuilder-类" class="headerlink" title="Java StringBuffer 和 StringBuilder 类"></a>Java StringBuffer 和 StringBuilder 类</h3><ul><li>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</li><li>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</li></ul><h3 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h3><ul><li>声明数组变量</li></ul><pre class=" language-java"><code class="language-java">dataType<span class="token punctuation">[</span><span class="token punctuation">]</span> arrayRefVar<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 首选的方法</span>dataType arrayRefVar<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 效果相同，但不是首选方法</span></code></pre><h3 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 打印所有数组元素</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">double</span> element<span class="token operator">:</span> myList<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Java-正则表达式"><a href="#Java-正则表达式" class="headerlink" title="Java 正则表达式"></a>Java 正则表达式</h3><ul><li><p>捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组：</p><ul><li>((A)(B(C)))</li><li>(A)</li><li>(B(C))</li><li>(C)</li></ul></li><li><p><a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener"><strong>正则表达式语法</strong></a></p><blockquote><p> 在其他语言中，\ 表示：<strong>我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。</strong></p><p> 在 Java 中，\ 表示：<strong>我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义</strong></p><p> 所以，在其他的语言中（如Perl），一个反斜杠 \ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 \ 代表其他语言中的一个 \，这也就是为什么表示一位数字的正则表达式是 \d，而表示一个普通的反斜杠是 \\</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL语法手册</title>
      <link href="/ruan-jian/sql-yu-fa-shou-ce/"/>
      <url>/ruan-jian/sql-yu-fa-shou-ce/</url>
      
        <content type="html"><![CDATA[<p>主要参考：</p><ul><li><a href="http://www.runoob.com/w3cnote/sql-syntax-manual.html" target="_blank" rel="noopener">http://www.runoob.com/w3cnote/sql-syntax-manual.html</a></li><li><a href="http://www.w3school.com.cn/sql/sql_intro.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/sql/sql_intro.asp</a></li><li><a href="https://blog.csdn.net/whyshr/article/details/50978953" target="_blank" rel="noopener">https://blog.csdn.net/whyshr/article/details/50978953</a></li></ul><h2 id="主要结构："><a href="#主要结构：" class="headerlink" title="主要结构："></a>主要结构：</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> select_list <span class="token punctuation">[</span> <span class="token keyword">INTO</span> new_table <span class="token punctuation">]</span> <span class="token keyword">FROM</span> table_source <span class="token punctuation">[</span> <span class="token keyword">WHERE</span> search_condition <span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> group_by_expression <span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token keyword">HAVING</span> search_condition <span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> order_expression <span class="token punctuation">[</span> <span class="token keyword">ASC</span> <span class="token operator">|</span> <span class="token keyword">DESC</span> <span class="token punctuation">]</span> <span class="token punctuation">]</span> <span class="token keyword">LIMIT</span> number</code></pre><h2 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h2><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><p><strong>用途：</strong></p><p>从指定表中取出指定的列的数据。</p><p><strong>语法：</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table_name<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name</code></pre><h4 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h4><p><strong>用途：</strong></p><p>选取前n行。</p><p><strong>语法：</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 选取前50%行</span><span class="token keyword">SELECT</span> <span class="token keyword">TOP</span> <span class="token number">50</span> <span class="token keyword">PERCENT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name<span class="token comment" spellcheck="true">-- 选取前5行</span><span class="token keyword">SELECT</span> <span class="token keyword">TOP</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name</code></pre><h4 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a>Distinct</h4><p><strong>用途：</strong></p><p>DISTINCT 关键字被用作返回唯一的值（去重）。</p><p><strong>语法：</strong></p><pre class=" language-Sql"><code class="language-Sql">SELECT DISTINCT column-name(s) FROM table-name</code></pre><h4 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h4><p>可以在WHERE中使用的运算符</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">=</span><span class="token punctuation">,</span> <span class="token operator">&lt;></span><span class="token punctuation">,</span> <span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token punctuation">,</span> <span class="token operator">>=</span><span class="token punctuation">,</span> <span class="token operator">&lt;=</span><span class="token comment" spellcheck="true">-- 在某些 SQL 的版本中不等号 &lt; > 能被写作为 !=</span><span class="token operator">BETWEEN</span> value1 <span class="token operator">AND</span> value2<span class="token operator">AND</span><span class="token punctuation">,</span> <span class="token operator">OR</span><span class="token punctuation">,</span> <span class="token operator">NOT</span><span class="token operator">LIKE</span> <span class="token string">'%g'</span>  <span class="token comment" spellcheck="true">--以g结尾，‘%’为通配符</span></code></pre><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td>%</td><td>一个或多个字符</td></tr><tr><td>-</td><td>一个字符</td></tr><tr><td>[charlist]</td><td>字符列表中的任何一个字符</td></tr><tr><td>[^charlist] 或者 [!charlist]</td><td>任何一个非列表中字符</td></tr></tbody></table><h4 id="Alias"><a href="#Alias" class="headerlink" title="Alias"></a>Alias</h4><p><strong>用途：</strong></p><p>可用在表、结果集或者列上，为它们取一个逻辑名称。</p><p><strong>语法：</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 给列取别名</span><span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">AS</span> column_alias <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token comment" spellcheck="true">-- 给表取别名</span><span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">AS</span> table_alias</code></pre><h2 id="排序："><a href="#排序：" class="headerlink" title="排序："></a>排序：</h2><h4 id="Order-by"><a href="#Order-by" class="headerlink" title="Order by"></a>Order by</h4><p><strong>例子：</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> Company<span class="token punctuation">,</span> OrderNumber <span class="token keyword">FROM</span> Orders<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Company <span class="token keyword">DESC</span></code></pre><h2 id="分组："><a href="#分组：" class="headerlink" title="分组："></a>分组：</h2><h4 id="Group-by"><a href="#Group-by" class="headerlink" title="Group by"></a>Group by</h4><p><strong>用途：</strong></p><p>对结果集进行分组，常与汇总函数一起使用。</p><p><strong>语法：</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">column</span><span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token keyword">column</span></code></pre><h4 id="Having"><a href="#Having" class="headerlink" title="Having"></a>Having</h4><p><strong>用途：</strong></p><p>指定群组或汇总的搜寻条件。</p><p><strong>语法：</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">column</span><span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token keyword">column</span><span class="token keyword">HAVING</span> <span class="token function">SUM</span><span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span> condition <span class="token keyword">value</span></code></pre><blockquote><p>HAVING 通常与 GROUP BY 子句同时使用。不使用 GROUP BY 时，HAVING 则与 WHERE 子句功能相似.</p></blockquote><h2 id="拼接："><a href="#拼接：" class="headerlink" title="拼接："></a>拼接：</h2><h4 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h4><p><strong>用途：</strong></p><p>多个表按行拼接。</p><p><strong>语法：</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> field1<span class="token punctuation">,</span> field2<span class="token punctuation">,</span> field3<span class="token keyword">FROM</span> first_table<span class="token punctuation">[</span> <span class="token keyword">INNER</span> <span class="token operator">|</span> <span class="token keyword">LEFT</span> <span class="token operator">|</span> <span class="token keyword">RIGHT</span> <span class="token punctuation">]</span> <span class="token keyword">JOIN</span> second_table<span class="token keyword">ON</span> first_table<span class="token punctuation">.</span>keyfield <span class="token operator">=</span> second_table<span class="token punctuation">.</span>foreign_keyfield</code></pre><blockquote><ul><li>INNER JOIN: 返回的结果集是两个表中所有相匹配的数据。</li></ul><ul><li>LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行</li><li>RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行</li><li>FULL JOIN: 关键字会从左表和右表那里返回所有的行。</li></ul></blockquote><h4 id="UNION-和-UNION-ALL"><a href="#UNION-和-UNION-ALL" class="headerlink" title="UNION 和 UNION ALL"></a>UNION 和 UNION ALL</h4><p><strong>用途：</strong> </p><p>用于合并两个或多个 SELECT 语句的结果集.</p><p><strong>语法：</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table_name1<span class="token keyword">UNION</span><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table_name2</code></pre><hr><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><table><thead><tr><th style="text-align:left">Insert Into</th><th>插入</th></tr></thead><tbody><tr><td style="text-align:left">Update</td><td>更新表中原有数据</td></tr><tr><td style="text-align:left">Delete</td><td>删除表中数据</td></tr><tr><td style="text-align:left">Create TABLE</td><td>创建表</td></tr><tr><td style="text-align:left">ALTER TABLE table_name ADD column_name datatype</td><td>添加列</td></tr><tr><td style="text-align:left">ALTER TABLE table_name DROP COLUMN column_name</td><td>删除列</td></tr><tr><td style="text-align:left">Drop TABLE</td><td>删除biao</td></tr></tbody></table><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><table><thead><tr><th>count</th><th>统计行的数量</th></tr></thead><tbody><tr><td>sum</td><td>求和，已忽略NULL值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>max, min, abs, ceil, floor, sign</td><td>数学函数</td></tr><tr><td>sin, sinh, cos, cosh, tan, tanh, exp, log, power, sort,</td></tr></tbody></table><h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><p>参考链接：</p><ol><li><a href="https://prestodb.io/docs/current/functions/window.html" target="_blank" rel="noopener">https://prestodb.io/docs/current/functions/window.html</a></li><li><a href="http://yugouai.iteye.com/blog/1908121" target="_blank" rel="noopener">http://yugouai.iteye.com/blog/1908121</a> </li><li><a href="http://dwgeek.com/hadoop-hive-analytic-functions-examples.html/" target="_blank" rel="noopener">http://dwgeek.com/hadoop-hive-analytic-functions-examples.html/</a></li><li><a href="https://blog.csdn.net/elimago/article/details/2656387" target="_blank" rel="noopener">https://blog.csdn.net/elimago/article/details/2656387</a> </li><li><a href="http://www.aboutyun.com/thread-12848-1-1.html" target="_blank" rel="noopener">http://www.aboutyun.com/thread-12848-1-1.html</a> </li></ol><p><strong>LAST_VALUE</strong>: 取分组内排序后，截止到当前行，最后一个值。若要让窗口是整个组，需要指定窗口子句，以下代码指定了整个分组作为分析窗口。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span>last_value<span class="token punctuation">(</span>xxx<span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token keyword">partition</span> <span class="token keyword">by</span> xx <span class="token keyword">order</span> <span class="token keyword">by</span> x <span class="token keyword">rows</span> <span class="token operator">between</span> <span class="token keyword">unbounded</span> <span class="token keyword">preceding</span> <span class="token operator">and</span> <span class="token keyword">unbounded</span> <span class="token keyword">following</span><span class="token punctuation">)</span> <span class="token keyword">as</span> name<span class="token keyword">from</span> T</code></pre><h2 id="时间函数（presto）"><a href="#时间函数（presto）" class="headerlink" title="时间函数（presto）"></a>时间函数（presto）</h2><p>string to bigint timestamp:</p><pre class=" language-Sql"><code class="language-Sql">cast(to_unixtime(date_parse(str, '%Y-%m-%d %T')) as bigint)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个有关分解质因数的面试题</title>
      <link href="/shua-ti/yi-ge-you-guan-fen-jie-zhi-yin-shu-de-mian-shi-ti/"/>
      <url>/shua-ti/yi-ge-you-guan-fen-jie-zhi-yin-shu-de-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<p>问题：给定两个字符串s、m，初始长度都为1。定义两种操作：</p><blockquote><ol><li>m = s, s = 2s</li><li>s = s + m</li></ol></blockquote><p>问给定长度L时，最少要经过多次操作1和2，才能让s的长度为L。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>我们可以发现，无论执行多少个操作1和操作2都可以，用下面这种通式表示：</p><p><img src="../../images/Interview_P1.png" alt="Interview_P1"></p><blockquote><ul><li>以操作1开始，是因为s和m的初始值都是1，无论第一步执行操作1还是操作2，得到s、m的状态都为(m = 1, s = 2.)</li><li>操作2中的kn表示执行kn次操作2，其中kn &gt;= 0。</li></ul></blockquote><h4 id="推导s的通项公式："><a href="#推导s的通项公式：" class="headerlink" title="推导s的通项公式："></a>推导s的通项公式：</h4><p>如图所示，我们可以把操作1加上kn个操作2定义为一个大操作。下面我们来推到，经过n个大操作后s的长度。</p><blockquote><p>设经过第 $j$ 个操作1后，m的长度为 $m_j$，则经过第 $j$ 个大操作后：</p><p>$$<br>s_j =  (k_j + 2) \times m_j<br>$$</p><p>又因为 $m_j = s_{j-1}$，所以有：</p><p>$$<br>s_j = (k_j + 2) \times s_{j-1}<br>$$</p><p>因 $s_0 = 1$，所以s长度的通向公式为：</p><p>$$<br>s_n = (k_n + 2)(k_{n-1}+2)\times ~…~ \times (k_2 + 2)(k_1 + 2)<br>$$</p><p>此时，经过的操作总数为：</p><p>$$<br>O_n = \sum_{i=1}^n k_i + n<br>$$</p></blockquote><p>所以整个问题变成了给定$s_n$后求$O_n$的最小值。</p><h4 id="求解最少操作数："><a href="#求解最少操作数：" class="headerlink" title="求解最少操作数："></a>求解最少操作数：</h4><p>对比操作1、2，可以发现同样的次数，操作1能够使s的长度更快的增长。所以问题也就变成当$L = s_n$时，n越大，所经过的总操作数$O_n$越小。因为$s_n$是n个大于等于2的因子连乘的形式，求n的最大值就变成了对$s_n$分解质因数后，所拆成的练乘因子个数。</p><h3 id="程序设计："><a href="#程序设计：" class="headerlink" title="程序设计："></a>程序设计：</h3><p>首先根据，L的最大值，建立最大值$&lt;=L/2$的素数表。然后对输入的L进行质因数分解。<br>$$<br>L=P_nP_{n-1}\times~…~P_2P_1<br>$$</p><p>那么最小操作数为：</p><p>$$<br>min(O) = \sum_{i=1}^n (P_i-2)+n=\sum_{i=1}^n(P_i-1)<br>$$</p><h3 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现:"></a>程序实现:</h3><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a><a href="http://nbviewer.jupyter.org/github/chunchengwei/chunchengwei.github.io/blob/master/notebook/Interview_P1.ipynb" target="_blank" rel="noopener">Python</a></h4><h4 id="C"><a href="#C" class="headerlink" title="C++:"></a>C++:</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> MAX_PN 1000</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个有关二分法的面试题</title>
      <link href="/shua-ti/yi-ge-you-guan-er-fen-fa-de-mian-shi-ti/"/>
      <url>/shua-ti/yi-ge-you-guan-er-fen-fa-de-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<p>问题：给定一个有序数组，再给定一个数c，判断数组中是否存在两个数a，b，满足a + b = c。要求时间复杂度$O(n)$，空间复杂度$O(1)$。</p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>利用首尾两个指针，计算首尾的和，如果小于c，就移动首指针+1，否则就移动尾指针-1。当首尾指针相邻时，仍未找满足要求的a和b，就返回false。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">check_add</span><span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">*</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">double</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">double</span> <span class="token operator">*</span> front <span class="token operator">=</span> data<span class="token punctuation">;</span>  <span class="token keyword">double</span> <span class="token operator">*</span> back <span class="token operator">=</span> data <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>front <span class="token operator">-</span> back<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token operator">*</span>front <span class="token operator">+</span> <span class="token operator">*</span>back<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> x<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> x<span class="token punctuation">)</span>      front<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>      back<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Five-point stencil</title>
      <link href="/suan-fa/five-point-stencil/"/>
      <url>/suan-fa/five-point-stencil/</url>
      
        <content type="html"><![CDATA[<p>Five-point stencil 在一维和二维中的形式：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Five_point_stencil_illustration.png/440px-Five_point_stencil_illustration.png" style="zoom:50%"></p><p>在数值分析中，给定一个一维或二维的网格，某一点的 <a href="https://en.wikipedia.org/wiki/Five-point_stencil" target="_blank" rel="noopener">Five-point stencil</a>（FPS）即为该点加上它邻近的四个点。FPS主要用于求解导数在格点上的有限差分近似。</p><h2 id="One-dimension"><a href="#One-dimension" class="headerlink" title="One dimension"></a>One dimension</h2><p>在一维情况下，如果格点宽度为 $h$ ，对于点 $x$ 的FPS为：<br>$$<br>{x-2h,x-h,x,x+h,x+2h}<br>$$</p><h3 id="一阶导数"><a href="#一阶导数" class="headerlink" title="一阶导数"></a>一阶导数</h3><p>$$<br>f’(x)\approx\frac{-f(x+2h)+8f(x+h)-8f(x-h)+f(x-2h)}{12h}<br>$$</p><h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><p>将$f(x)$在点$x\pm h,x\pm 2h$处进行Taylor展开：</p><p>$$<br>f(x\pm h)=f(x)\pm hf’(x)+\frac{h^2}{2!}f’’(x)\pm\frac{h^3}{3!}f^{(3)}(x)+O_{1\pm}(h^4)<br>$$</p><p>$$<br>f(x\pm2h)=f(x)\pm2hf’(x)+\frac{4h^2}{2!}f’’(x)\pm\frac{8h^3}{3!}f^{(3)}(x)+O_{2\pm}(h^4)<br>$$</p><p>分别相消有：</p><p>$$<br>f(x+h)-f(x-h)=2hf’(x)+\frac{h^3}{3}f^{(3)}(x)+O_1(h^4)<br>$$</p><p>$$<br>f(x+2h)-f(x-2h)=4hf’(x)+\frac{8h^3}{3}f^{(3)}(x)+O_2(h^4)<br>$$</p><p>消去3阶项有：</p><p>$$<br>8f(x+h)-8f(x-h)-f(x+2h)+f(x-2h)=12hf’(x)+O(h^4)<br>$$</p><h3 id="误差"><a href="#误差" class="headerlink" title="误差"></a>误差</h3><p>$$<br>\frac{-f(x+2h)+8f(x+h)-8f(x-h)+f(x-2h)}{12h}=f’(x)-\frac{1}{30}f^{(5)}(x)h^4+O(h^5)<br>$$</p><p>所以误差为$h^4$量级。</p><h2 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h2><p>同样的方法可以推导出更高阶的导数：</p><p>$$<br>f’’(x)\approx\frac{-f(x+2h)+16f(x+h)-30f(x)+16f(x-h)-f(x-2h)}{12h^2}<br>$$</p><p>$$<br>f^{(3)}(x)\approx\frac{f(x+2h)-2f(x+h)+2f(x-h)-f(x-2h)}{2h^3}<br>$$</p><p>$$<br>f^{(4)}(x)\approx\frac{f(x+2h)-4f(x+h)+6f(x)-4f(x-h)+f(x-2h)}{h^4}<br>$$</p><p>误差分别为$O(h^4),O(h2),O(h^2)$量级。</p><hr><h5 id="更多内容参照维基百科："><a href="#更多内容参照维基百科：" class="headerlink" title="更多内容参照维基百科："></a>更多内容参照维基百科：</h5><ul><li><a href="https://en.wikipedia.org/wiki/Five-point_stencil" target="_blank" rel="noopener">Five-point stencil</a></li><li><a href="https://en.wikipedia.org/wiki/Numerical_differentiation" target="_blank" rel="noopener">Numerical differentiation</a></li><li><a href="https://en.wikipedia.org/wiki/Finite_difference_coefficient" target="_blank" rel="noopener">Finite difference coefficient</a></li><li><a href="http://web.media.mit.edu/~crtaylor/calculator.html" target="_blank" rel="noopener">Finite Difference Coefficients Calculator</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>黄金分割搜索</title>
      <link href="/suan-fa/huang-jin-fen-ge-sou-suo/"/>
      <url>/suan-fa/huang-jin-fen-ge-sou-suo/</url>
      
        <content type="html"><![CDATA[<p>适用于，一维单峰函数搜索最小值或者最大值。</p><h3 id="核心思想："><a href="#核心思想：" class="headerlink" title="核心思想："></a>核心思想：</h3><p>基于函数是一维单峰的特性，通过三个点来判断函数的大致走向，并且可以知道最小值一定落在已知最小点的相邻两点所界定的区间内。所以可以通过在区间内插入新的点，来逐步缩小最小值的所在的区间。</p><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/52/GoldenSectionSearch.png/650px-GoldenSectionSearch.png" style="zoom:50%"></p><p>如图所示，如果点$x_4$的值为$f_{4a}$，则最小值落在$[x_1,x_4]$，相反如果值为$f_{4b}$的话，则最小值落在$[x_2,x_3]$。</p><h3 id="点的选取："><a href="#点的选取：" class="headerlink" title="点的选取："></a>点的选取：</h3><p>为了使得每次搜索的均衡，则要求$a+c=b$。</p><p>为了确保每一次搜索后，最小值所在的区间能按相同的比例缩小，则要求：$c/a=a/b$。</p><p>联立两式可得，$\frac{a}{b}=\frac{1+\sqrt{5}}{2}=1.618033988…$</p><p>这个正是黄金比例，所以该算法叫做黄金分割搜索。</p><hr><h2 id="扩展阅读："><a href="#扩展阅读：" class="headerlink" title="扩展阅读："></a>扩展阅读：</h2><ul><li><a href="https://en.wikipedia.org/wiki/Golden-section_search" target="_blank" rel="noopener">Golden-section search</a></li><li><a href="https://www.guokr.com/question/609840/" target="_blank" rel="noopener">一维搜索中黄金分割法和二分法哪个快？</a></li><li><a href="https://baike.baidu.com/item/斐波那契数列" target="_blank" rel="noopener">斐波那契数列</a></li><li><a href="https://baike.baidu.com/item/特征方程" target="_blank" rel="noopener">线性递推数列特征方程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Minimization </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决numpy 0d arrays error</title>
      <link href="/ruan-jian/jie-jue-numpy-0d-arrays-error/"/>
      <url>/ruan-jian/jie-jue-numpy-0d-arrays-error/</url>
      
        <content type="html"><![CDATA[<p>使用numpy array时，可能会遇到 <strong><em>“iteration over a 0-d array”</em></strong> 的错误。</p><h6 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h6><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npa <span class="token operator">=</span> <span class="token number">1</span>a <span class="token operator">=</span> np<span class="token punctuation">.</span>asarray<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> a<span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python">TypeError<span class="token punctuation">:</span> iteration over a <span class="token number">0</span><span class="token operator">-</span>d array</code></pre><h6 id="例2"><a href="#例2" class="headerlink" title="例2:"></a>例2:</h6><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npa<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span>a<span class="token punctuation">,</span> b <span class="token operator">=</span> np<span class="token punctuation">.</span>asarray<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>asarray<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token keyword">in</span> zip<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python">TypeError<span class="token punctuation">:</span> zip argument <span class="token comment" spellcheck="true">#1 must support iteration</span></code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h2><p>使用 <strong><em>numpy.atleast_1d()</em></strong> 即可：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npa<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span>a<span class="token punctuation">,</span> b <span class="token operator">=</span> np<span class="token punctuation">.</span>atleast_1d<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>atleast_1d<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token keyword">in</span> zip<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span></code></pre><p>参考资料：<a href="https://stackoverflow.com/questions/35617073/python-numpy-how-to-best-deal-with-possible-0d-arrays" target="_blank" rel="noopener">Python, numpy; How to best deal with possible 0d arrays</a>.</p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Scipy积分</title>
      <link href="/ruan-jian/scipy-ji-fen/"/>
      <url>/ruan-jian/scipy-ji-fen/</url>
      
        <content type="html"><![CDATA[<h2 id="数值积分"><a href="#数值积分" class="headerlink" title="数值积分"></a>数值积分</h2><h3 id="一重积分（SciPy-integrate-quad）："><a href="#一重积分（SciPy-integrate-quad）：" class="headerlink" title="一重积分（SciPy.integrate.quad）："></a>一重积分（<em>SciPy.integrate.quad</em>）：</h3><p>例子为求解单位半圆的面积：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> scipy <span class="token keyword">import</span> integrate<span class="token keyword">def</span> <span class="token function">half_circle</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>x<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">0.5</span>pi_half<span class="token punctuation">,</span> err <span class="token operator">=</span> integrate<span class="token punctuation">.</span>quad<span class="token punctuation">(</span>half_circle<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>结果为：</p><pre class=" language-python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> pi_half<span class="token operator">*</span><span class="token number">2</span>Out<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">3.1415926535897967</span>In <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> errOut<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">1.0002354500215915e-09</span></code></pre><p><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/integrate.html" target="_blank" rel="noopener">https://docs.scipy.org/doc/scipy/reference/tutorial/integrate.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> SciPy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 4</title>
      <link href="/leetcode/leetcode-4/"/>
      <url>/leetcode/leetcode-4/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h2><p>给定两个排好序的数组，大小分别为$m$和$n$，找到两个数组的中位数（median），要求时间复杂度不超过$O(log(m+n))$.</p><p><strong>Example 1:</strong></p><blockquote><p>nums1 = [1, 3]</p><p>nums2 = [2]</p><p>The median is 2.0</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>nums1 = [1, 2]</p><p>nums2 = [3, 4]</p><p>The median is (2 + 3)/2 = 2.5</p></blockquote><h6 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h6><p><strong>中位数：</strong>是在一组数据中居于中间的数(特别注意的地方是：这组数据之前已经经过升序排列！！！)，即在这组数据中，有一半的数据比它大，有一半的数据比它小。如果这组数据包含偶数个数字，中值是位于中间的两个数的平均值。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h2><p><img src="../../images/LeetCode4.jpg" alt="LeetCode4"></p><h3 id="主要思路："><a href="#主要思路：" class="headerlink" title="主要思路："></a>主要思路：</h3><p>如上图所示，想要找到两个数组合并后的中位数，即寻找 $C_{k-1}$ 和 $C_k$ 的值，即找到合并后数组的第K个元素。</p><h4 id="思路1："><a href="#思路1：" class="headerlink" title="思路1："></a>思路1：</h4><p>依次从数组nums1和nums2数组的头部弹出较小的值，直到找到第K个元素。这种算法的时间复杂度为 $O(m+n)$。</p><h4 id="思路2："><a href="#思路2：" class="headerlink" title="思路2："></a>思路2：</h4><p>假设从nums1中取出前m1个元素，nums2中取出前m2个元素，共同组成合并后数组的前k个元素。当：</p><p>$$<br>A_{m_1}&gt;=B_{m_2-1}\quad\&amp;\&amp;\quad B_{m_2}&gt;=A_{m_1-1}<br>$$</p><p>成立时，才为合理解，否则说明m1取得过大或者过小。</p><p>当找到m1时，那么：</p><p>$$<br>C_{k-1}=max(A_{m1-1},B_{m_2-1})<br>$$</p><p>$$<br>C_k=min(A_{m_1},B_{m_2})<br>$$</p><p>当$(m+n)$为奇数时，中位数为$C_{k-1}$ 。偶数时为$0.5*(C_{k-1}+C_k)$ 。</p><p>代码如下：</p><blockquote><p>Runtime: <strong>69 ms</strong>,  beats 25.76% of cpp submissions.</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">double</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token keyword">int</span> n1 <span class="token operator">=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> <span class="token keyword">int</span> n2 <span class="token operator">=</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n2 <span class="token operator">&lt;</span> n1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span>nums2<span class="token punctuation">,</span> nums1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token punctuation">(</span>n1 <span class="token operator">+</span> n2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> n1<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">const</span> <span class="token keyword">int</span> m1 <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">const</span> <span class="token keyword">int</span> m2 <span class="token operator">=</span> k <span class="token operator">-</span> m1<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>m1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>m2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                l <span class="token operator">=</span> m1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> m1<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">const</span> <span class="token keyword">int</span> m1 <span class="token operator">=</span> r<span class="token punctuation">;</span>        <span class="token keyword">const</span> <span class="token keyword">int</span> m2 <span class="token operator">=</span> k <span class="token operator">-</span> m1<span class="token punctuation">;</span>        <span class="token keyword">const</span> <span class="token keyword">int</span> c1 <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>m1 <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">?</span> INT_MIN <span class="token operator">:</span> nums1<span class="token punctuation">[</span>m1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                           m2 <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">?</span> INT_MIN <span class="token operator">:</span> nums2<span class="token punctuation">[</span>m2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n1 <span class="token operator">+</span> n2<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> c1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// even</span>        <span class="token keyword">const</span> <span class="token keyword">int</span> c2 <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>m1 <span class="token operator">>=</span> n1 <span class="token operator">?</span> INT_MAX <span class="token operator">:</span> nums1<span class="token punctuation">[</span>m1<span class="token punctuation">]</span><span class="token punctuation">,</span>                           m2 <span class="token operator">>=</span> n2 <span class="token operator">?</span> INT_MAX <span class="token operator">:</span> nums2<span class="token punctuation">[</span>m2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>c1 <span class="token operator">+</span> c2<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 2</title>
      <link href="/leetcode/leetcode-2/"/>
      <url>/leetcode/leetcode-2/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h2><p>给定两个非空链表代表两个非负整数。数字按逆序存储在每个节点上。求两个数字的和，并按链表的方式返回。</p><p>例如：</p><blockquote><p><strong>Input:</strong> (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p><p><strong>Output:</strong> 7 -&gt; 0 -&gt; 8</p><p><strong>Explanation:</strong> 342 + 465 = 807.</p></blockquote><h2 id="解法"><a href="#解法" class="headerlink" title="解法:"></a>解法:</h2><h3 id="迭代："><a href="#迭代：" class="headerlink" title="迭代："></a>迭代：</h3><p>首先用迭代的方式，主要是注意边界的处理。这种代码比较长，提交LeetCode后显示代码效率并不高，只能排到30%多。</p><p>代码如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode<span class="token operator">*</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> sum <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sum <span class="token operator">=</span> sum<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            sum<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">=</span> l1<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">+</span> l2<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">+</span> carry<span class="token punctuation">;</span>            carry <span class="token operator">=</span> sum<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>            sum<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">=</span> sum<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            l1 <span class="token operator">=</span> l1<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            l2 <span class="token operator">=</span> l2<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>l1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    sum<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">(</span>l1<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">+</span> carry<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    carry <span class="token operator">=</span> <span class="token punctuation">(</span>l1<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">+</span> carry<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>                    sum <span class="token operator">=</span> sum<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>                    l1 <span class="token operator">=</span> l1<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>carry<span class="token punctuation">)</span>                    sum<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>carry<span class="token punctuation">)</span><span class="token punctuation">;</span>                ListNode<span class="token operator">*</span> temp <span class="token operator">=</span> head<span class="token punctuation">;</span>                head <span class="token operator">=</span> head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>                <span class="token keyword">delete</span> temp<span class="token punctuation">;</span>                <span class="token keyword">return</span> head<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">(</span>l2<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">+</span> carry<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            carry <span class="token operator">=</span> <span class="token punctuation">(</span>l2<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">+</span> carry<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>            sum <span class="token operator">=</span> sum<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            l2 <span class="token operator">=</span> l2<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>carry<span class="token punctuation">)</span>            sum<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>carry<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> temp <span class="token operator">=</span> head<span class="token punctuation">;</span>        head <span class="token operator">=</span> head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">delete</span> temp<span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><hr><h3 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h3><p>另一种方法是用递归。代码简单明了，提交LeetCode后能排到64.48%。</p><p>代码如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">add</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode<span class="token operator">*</span> <span class="token function">add</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">,</span> <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> carry <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token constant">NULL</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>carry<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            x <span class="token operator">=</span> l1<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>               l1 <span class="token operator">=</span> l1<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>           <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            y <span class="token operator">=</span> l2<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>               l2 <span class="token operator">=</span> l2<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>           <span class="token punctuation">}</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> x <span class="token operator">+</span> y <span class="token operator">+</span> carry<span class="token punctuation">;</span>        carry <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> curr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        curr<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">,</span> carry<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> curr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><hr><h3 id="大神解法："><a href="#大神解法：" class="headerlink" title="大神解法："></a>大神解法：</h3><p>下面是LeetCode上大神的解法，我改成了C++版本的，大神的貌似没有删除不用的节点，这样应该会导致内存泄漏。在C++版本中改进了这一点，但是代码效率就降下来了。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode<span class="token operator">*</span> dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> curr <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>        <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> l2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> l1<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>            <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> l2<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> x <span class="token operator">+</span> y <span class="token operator">+</span> carry<span class="token punctuation">;</span>            carry <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>            curr<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> l1 <span class="token operator">=</span> l1<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> l2 <span class="token operator">=</span> l2<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>carry <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>             curr<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>carry<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// delete not used ListNode. but when add this, runtime beat 34%,</span>        <span class="token comment" spellcheck="true">// when remove this, runtime bests 85.74%</span>        curr <span class="token operator">=</span> dummyHead<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">delete</span> dummyHead<span class="token punctuation">;</span>        <span class="token keyword">return</span> curr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 3</title>
      <link href="/leetcode/leetcode-3/"/>
      <url>/leetcode/leetcode-3/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h2><p>给定一个string，找到最长不含有重复字符的字串。返回其长度。</p><p>例如：</p><blockquote><p>”abcabcbb“的最长不含重复字符的字串是”abc“，长度为3。</p><p>”bbbbb“的最长不含重复字符的字串是”b“，长度为1。</p><p>”pwwkew“的最长不含重复字符的字串是”wke“，长度为3。注意答案要求必须是字串，”pwke“只是子序列不是字串。</p></blockquote><h2 id="解法"><a href="#解法" class="headerlink" title="解法:"></a>解法:</h2><h3 id="主要思路："><a href="#主要思路：" class="headerlink" title="主要思路："></a>主要思路：</h3><p>建立数组length，用来存以当前字符结尾的最长不含重复字符的字串长度。循环字符串，并更新length数组。length中的最大值即为本题答案。</p><p>代码如下：</p><blockquote><p>Runtime: <strong>31 ms</strong>, beats 57.85% of cpp submissions.</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max_end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            string<span class="token operator">::</span>iterator p <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i <span class="token operator">-</span> length<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">)</span>                length<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i <span class="token operator">-</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                length<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>length<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            max_end <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>max_end<span class="token punctuation">,</span> length<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max_end<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><hr><h3 id="大神解法："><a href="#大神解法：" class="headerlink" title="大神解法："></a>大神解法：</h3><p>还没看，待更新。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
